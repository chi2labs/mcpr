#!/usr/bin/env node

/**
 * Enhanced Node.js wrapper for math-tools MCP Server with Protocol Support
 * 
 * This wrapper implements the R↔Node.js communication protocol, handling:
 * - Bidirectional message passing between MCP clients and R
 * - Message correlation using IDs
 * - Error handling without stderr leakage
 * - Special R value conversion
 * 
 * Generated by mcpr (https://github.com/chi2labs/mcpr)
 */

const { spawn } = require('child_process');
const path = require('path');
const readline = require('readline');

// Configuration
const SERVER_NAME = 'math-tools';
const R_SCRIPT = 'server.R';
const DEBUG = process.env.MCPR_DEBUG === 'true';

// Path to R script
const scriptPath = path.join(__dirname, R_SCRIPT);

// Message tracking for request/response correlation
const pendingRequests = new Map();
let messageIdCounter = 0;

// Spawn Rscript process with appropriate flags
const rProcess = spawn('Rscript', ['--no-echo', scriptPath], {
  stdio: ['pipe', 'pipe', 'pipe'],
  env: {
    ...process.env,
    MCPR_SERVER_NAME: SERVER_NAME,
    MCPR_PROTOCOL_MODE: 'true'
  }
});

// Create readline interfaces for structured line reading
const clientReader = readline.createInterface({
  input: process.stdin,
  terminal: false
});

const rReader = readline.createInterface({
  input: rProcess.stdout,
  terminal: false
});

/**
 * Generate unique message ID
 */
function generateMessageId() {
  return `node_${Date.now()}_${++messageIdCounter}`;
}

/**
 * Convert MCP JSON-RPC request to internal protocol message
 */
function mcpToProtocol(mcpMessage) {
  const protocolMessage = {
    id: mcpMessage.id || generateMessageId(),
    type: mcpMessage.id ? 'request' : 'notification',
    method: mcpMessage.method,
    params: mcpMessage.params || {}
  };
  
  return protocolMessage;
}

/**
 * Convert internal protocol response to MCP JSON-RPC response
 */
function protocolToMcp(protocolMessage, originalId) {
  const mcpMessage = {
    jsonrpc: '2.0',
    id: originalId
  };
  
  if (protocolMessage.type === 'response') {
    mcpMessage.result = protocolMessage.result;
  } else if (protocolMessage.type === 'error') {
    mcpMessage.error = protocolMessage.error;
  }
  
  return mcpMessage;
}

/**
 * Handle special R values in objects
 */
function processRValues(obj) {
  if (typeof obj === 'string') {
    // Convert special R value markers
    if (obj === '__R_POS_INF__') return Infinity;
    if (obj === '__R_NEG_INF__') return -Infinity;
    if (obj === '__R_NAN__') return NaN;
    return obj;
  } else if (Array.isArray(obj)) {
    return obj.map(processRValues);
  } else if (obj && typeof obj === 'object') {
    const result = {};
    for (const key in obj) {
      result[key] = processRValues(obj[key]);
    }
    return result;
  }
  return obj;
}

/**
 * Send message to R process
 */
function sendToR(message) {
  const json = JSON.stringify(message);
  if (DEBUG) {
    console.error(`[Node→R] ${json}`);
  }
  rProcess.stdin.write(json + '\n');
}

/**
 * Send message to MCP client
 */
function sendToClient(message) {
  const json = JSON.stringify(message);
  if (DEBUG) {
    console.error(`[Node→Client] ${json}`);
  }
  process.stdout.write(json + '\n');
}

// Handle messages from MCP client
clientReader.on('line', (line) => {
  try {
    const mcpMessage = JSON.parse(line);
    
    if (DEBUG) {
      console.error(`[Client→Node] ${line}`);
    }
    
    // Check if this is a direct passthrough method (MCP protocol)
    if (mcpMessage.method && mcpMessage.method.startsWith('mcp/')) {
      // For MCP protocol methods, pass through directly
      sendToR(line);
    } else {
      // Convert to internal protocol
      const protocolMessage = mcpToProtocol(mcpMessage);
      
      // Track request if it expects a response
      if (mcpMessage.id) {
        pendingRequests.set(protocolMessage.id, {
          originalId: mcpMessage.id,
          timestamp: Date.now()
        });
      }
      
      // Send to R
      sendToR(protocolMessage);
    }
  } catch (error) {
    console.error(`Failed to parse client message: ${error.message}`);
    // Send error response if we can determine the ID
    try {
      const partialParse = JSON.parse(line);
      if (partialParse.id) {
        sendToClient({
          jsonrpc: '2.0',
          id: partialParse.id,
          error: {
            code: -32700,
            message: 'Parse error',
            data: error.message
          }
        });
      }
    } catch (e) {
      // Cannot recover, ignore
    }
  }
});

// Handle messages from R process
rReader.on('line', (line) => {
  try {
    let message = JSON.parse(line);
    
    if (DEBUG) {
      console.error(`[R→Node] ${line}`);
    }
    
    // Check if this is already MCP formatted (direct passthrough)
    if (message.jsonrpc === '2.0') {
      // Direct MCP message, pass through
      sendToClient(message);
    } else {
      // Internal protocol message
      message = processRValues(message);
      
      // Find corresponding request
      const request = pendingRequests.get(message.id);
      if (request) {
        // Convert to MCP response
        const mcpResponse = protocolToMcp(message, request.originalId);
        sendToClient(mcpResponse);
        
        // Clean up
        pendingRequests.delete(message.id);
      } else if (message.type === 'notification') {
        // R-initiated notification (rare but possible)
        sendToClient({
          jsonrpc: '2.0',
          method: message.method,
          params: message.params
        });
      }
    }
  } catch (error) {
    console.error(`Failed to parse R message: ${error.message}`);
  }
});

// Clean up old pending requests periodically
setInterval(() => {
  const now = Date.now();
  const timeout = 60000; // 1 minute timeout
  
  for (const [id, request] of pendingRequests.entries()) {
    if (now - request.timestamp > timeout) {
      // Send timeout error
      sendToClient({
        jsonrpc: '2.0',
        id: request.originalId,
        error: {
          code: -32000,
          message: 'Request timeout',
          data: `Request ${id} timed out after ${timeout}ms`
        }
      });
      pendingRequests.delete(id);
    }
  }
}, 10000); // Check every 10 seconds

// Filter R stderr to remove debug messages
rProcess.stderr.on('data', (data) => {
  const msg = data.toString();
  
  // Define patterns to filter out
  const filterPatterns = [
    /^Starting .* server/i,
    /^R version:/,
    /^Working directory:/,
    /^MCP Server started/i,
    /^MCP Server stopped/i,
    /^EOF reached/i,
    /^Shutting down/i,
    /^\[Protocol\]/,  // Protocol debug messages
    // Add any server-specific patterns here
    
  ];
  
  // Check if the message matches any filter pattern
  const shouldFilter = filterPatterns.some(pattern => pattern.test(msg));
  
  // Only pass through actual errors
  if (!shouldFilter) {
    process.stderr.write(data);
  }
});

// Handle R process exit
rProcess.on('exit', (code) => {
  // Send error responses for any pending requests
  for (const [id, request] of pendingRequests.entries()) {
    sendToClient({
      jsonrpc: '2.0',
      id: request.originalId,
      error: {
        code: -32000,
        message: 'Server shutdown',
        data: 'R process exited unexpectedly'
      }
    });
  }
  
  process.exit(code || 0);
});

// Handle errors starting R process
rProcess.on('error', (err) => {
  console.error(`Failed to start R process for ${SERVER_NAME}:`, err);
  process.exit(1);
});

// Handle termination signals
process.on('SIGTERM', () => {
  rProcess.kill('SIGTERM');
});

process.on('SIGINT', () => {
  rProcess.kill('SIGINT');
});

// Handle uncaught exceptions
process.on('uncaughtException', (err) => {
  console.error(`Uncaught exception in ${SERVER_NAME} wrapper:`, err);
  rProcess.kill('SIGTERM');
  process.exit(1);
});
