#!/usr/bin/env node

/**
 * Node.js wrapper for {{SERVER_NAME}} MCP Server
 * 
 * This wrapper implements the R↔Node.js communication protocol, handling:
 * - Reliable stdin/stdout communication with R subprocess
 * - Message correlation and error handling
 * - Filtering of stderr to prevent MCP client connection failures
 * 
 * Generated by mcpr (https://github.com/chi2labs/mcpr)
 */

const { spawn } = require('child_process');
const path = require('path');
const readline = require('readline');

// Configuration
const SERVER_NAME = '{{SERVER_NAME}}';
const R_SCRIPT = '{{R_SCRIPT_NAME}}';
const USE_PROTOCOL = process.env.MCPR_USE_PROTOCOL !== 'false'; // Default to true
const DEBUG = process.env.MCPR_DEBUG === 'true';

// Path to R script
const scriptPath = path.join(__dirname, R_SCRIPT);

// For protocol mode, we need message tracking
const pendingMessages = new Map();
let messageCounter = 0;

// Spawn Rscript process with appropriate flags
const rProcess = spawn('Rscript', ['--no-echo', scriptPath], {
  stdio: ['pipe', 'pipe', 'pipe'],
  env: {
    ...process.env,
    MCPR_SERVER_NAME: SERVER_NAME,
    MCPR_USE_PROTOCOL: USE_PROTOCOL ? 'true' : 'false'
  }
});

if (!USE_PROTOCOL) {
  // Simple passthrough mode (legacy)
  process.stdin.pipe(rProcess.stdin);
  rProcess.stdout.pipe(process.stdout);
} else {
  // Protocol mode with message handling
  const clientReader = readline.createInterface({
    input: process.stdin,
    terminal: false
  });

  const rReader = readline.createInterface({
    input: rProcess.stdout,
    terminal: false
  });

  // Handle client messages
  clientReader.on('line', (line) => {
    if (DEBUG) console.error(`[Client→Node] ${line}`);
    
    try {
      const message = JSON.parse(line);
      
      // Add tracking info if needed
      if (message.id && message.method) {
        pendingMessages.set(message.id, {
          timestamp: Date.now(),
          method: message.method
        });
      }
      
      // Forward to R
      rProcess.stdin.write(line + '\n');
    } catch (e) {
      // If not valid JSON, pass through as-is
      rProcess.stdin.write(line + '\n');
    }
  });

  // Handle R messages
  rReader.on('line', (line) => {
    if (DEBUG) console.error(`[R→Node] ${line}`);
    
    try {
      const message = JSON.parse(line);
      
      // Clean up tracking if this is a response
      if (message.id && (message.result !== undefined || message.error !== undefined)) {
        pendingMessages.delete(message.id);
      }
      
      // Forward to client
      process.stdout.write(line + '\n');
    } catch (e) {
      // If not valid JSON, pass through as-is
      process.stdout.write(line + '\n');
    }
  });

  // Periodic cleanup of old pending messages
  if (USE_PROTOCOL) {
    setInterval(() => {
      const now = Date.now();
      const timeout = 60000; // 1 minute
      
      for (const [id, info] of pendingMessages.entries()) {
        if (now - info.timestamp > timeout) {
          if (DEBUG) console.error(`[Node] Cleaning up timed out message: ${id}`);
          pendingMessages.delete(id);
        }
      }
    }, 30000); // Every 30 seconds
  }
}

// Filter R stderr to remove debug messages
// This is critical - any stderr output breaks MCP client connections
rProcess.stderr.on('data', (data) => {
  const msg = data.toString();
  
  // Define patterns to filter out (customize as needed)
  const filterPatterns = [
    /^Starting .* server/i,
    /^R version:/,
    /^Working directory:/,
    /^MCP Server started/i,
    /^MCP Server stopped/i,
    /^EOF reached/i,
    /^Shutting down/i,
    // Add any server-specific patterns here
    {{ADDITIONAL_FILTERS}}
  ];
  
  // Check if the message matches any filter pattern
  const shouldFilter = filterPatterns.some(pattern => pattern.test(msg));
  
  // Only pass through actual errors, not debug messages
  if (!shouldFilter) {
    process.stderr.write(data);
  }
});

// Handle R process exit
rProcess.on('exit', (code) => {
  process.exit(code || 0);
});

// Handle errors starting R process
rProcess.on('error', (err) => {
  console.error(`Failed to start R process for ${SERVER_NAME}:`, err);
  process.exit(1);
});

// Handle termination signals
process.on('SIGTERM', () => {
  rProcess.kill('SIGTERM');
});

process.on('SIGINT', () => {
  rProcess.kill('SIGINT');
});

// Handle uncaught exceptions
process.on('uncaughtException', (err) => {
  console.error(`Uncaught exception in ${SERVER_NAME} wrapper:`, err);
  rProcess.kill('SIGTERM');
  process.exit(1);
});
