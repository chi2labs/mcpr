#!/usr/bin/env node

/**
 * Node.js wrapper for {{SERVER_NAME}} MCP Server
 * 
 * This wrapper is required because R cannot reliably handle stdin when
 * launched as a subprocess. It also filters stderr to prevent connection
 * failures with MCP clients.
 * 
 * Generated by mcpr (https://github.com/chi2labs/mcpr)
 */

const { spawn } = require('child_process');
const path = require('path');

// Configuration
const SERVER_NAME = '{{SERVER_NAME}}';
const R_SCRIPT = '{{R_SCRIPT_NAME}}';

// Path to R script
const scriptPath = path.join(__dirname, R_SCRIPT);

// Spawn Rscript process with appropriate flags
const rProcess = spawn('Rscript', ['--no-echo', scriptPath], {
  stdio: ['pipe', 'pipe', 'pipe'],
  env: {
    ...process.env,
    // Pass any additional environment variables if needed
    MCPR_SERVER_NAME: SERVER_NAME
  }
});

// Pipe stdin to R process
process.stdin.pipe(rProcess.stdin);

// Pipe R stdout to our stdout
rProcess.stdout.pipe(process.stdout);

// Filter R stderr to remove debug messages
// This is critical - any stderr output breaks MCP client connections
rProcess.stderr.on('data', (data) => {
  const msg = data.toString();
  
  // Define patterns to filter out (customize as needed)
  const filterPatterns = [
    /^Starting .* server/i,
    /^R version:/,
    /^Working directory:/,
    /^MCP Server started/i,
    /^MCP Server stopped/i,
    /^EOF reached/i,
    /^Shutting down/i,
    // Add any server-specific patterns here
    {{ADDITIONAL_FILTERS}}
  ];
  
  // Check if the message matches any filter pattern
  const shouldFilter = filterPatterns.some(pattern => pattern.test(msg));
  
  // Only pass through actual errors, not debug messages
  if (!shouldFilter) {
    process.stderr.write(data);
  }
});

// Handle R process exit
rProcess.on('exit', (code) => {
  process.exit(code || 0);
});

// Handle errors starting R process
rProcess.on('error', (err) => {
  console.error(`Failed to start R process for ${SERVER_NAME}:`, err);
  process.exit(1);
});

// Handle termination signals
process.on('SIGTERM', () => {
  rProcess.kill('SIGTERM');
});

process.on('SIGINT', () => {
  rProcess.kill('SIGINT');
});

// Handle uncaught exceptions
process.on('uncaughtException', (err) => {
  console.error(`Uncaught exception in ${SERVER_NAME} wrapper:`, err);
  rProcess.kill('SIGTERM');
  process.exit(1);
});